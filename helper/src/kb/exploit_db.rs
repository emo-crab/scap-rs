use crate::kb::create_or_update_exploit;
use crate::kb::serde_format::date_format;
use crate::kb::serde_format::rfc3339_deserialize;
use crate::Connection;
use chrono::{Duration, NaiveDateTime, Utc};
use nvd_model::knowledge_base::db::{CreateKnowledgeBase, KBSource, KBTypes};
use nvd_model::types::{AnyValue, MetaData};
use reqwest::header;
use serde::{Deserialize, Serialize};
use std::collections::HashSet;

#[derive(Deserialize, Serialize, Debug, Clone)]
#[serde(rename_all = "kebab-case")]
pub struct Rss {
  channel: Channel,
}

impl Rss {
  pub async fn update(&self, conn: &mut Connection) {
    for item in &self.channel.item {
      // 发布时间小于三天前跳过更新
      if item.published < (Utc::now() - Duration::days(3)).naive_utc() {
        continue;
      }
      get_info_from_exploit_url(conn, item).await;
    }
  }
}

#[derive(Deserialize, Serialize, Debug, Clone)]
#[serde(rename_all = "kebab-case")]
struct Channel {
  item: Vec<Item>,
}

#[derive(Deserialize, Serialize, Debug, Clone)]
#[serde(rename_all = "kebab-case")]
struct Item {
  title: String,
  link: String,
  description: String,
  #[serde(alias = "pubDate", deserialize_with = "rfc3339_deserialize")]
  published: NaiveDateTime,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct ExploitDB {
  id: u32,
  file: String,
  description: String,
  #[serde(with = "date_format")]
  date_published: NaiveDateTime,
  author: String,
  r#type: String,
  platform: String,
  port: Option<u16>,
  #[serde(with = "date_format")]
  date_added: NaiveDateTime,
  #[serde(with = "date_format")]
  date_updated: NaiveDateTime,
  verified: u8,
  codes: Option<String>,
  tags: Option<String>,
  aliases: Option<String>,
  screenshot_url: Option<String>,
  application_url: Option<String>,
  source_url: Option<String>,
}

impl From<ExploitDB> for CreateKnowledgeBase {
  fn from(val: ExploitDB) -> Self {
    let kb_item = val;
    let meta = if let Some(code) = kb_item.codes {
      MetaData::from_hashset(
        "tags",
        code
          .split(';')
          .map(|s| s.to_string())
          .collect::<HashSet<String>>(),
      )
    } else {
      MetaData::default()
    };
    CreateKnowledgeBase {
      id: uuid::Uuid::new_v4().as_bytes().to_vec(),
      name: kb_item.id.to_string(),
      description: kb_item.description,
      source: KBSource::ExploitDb.to_string(),
      path: kb_item.file,
      meta: AnyValue::new(meta.clone()),
      verified: kb_item.verified,
      created_at: kb_item.date_published,
      updated_at: kb_item.date_updated,
      types: KBTypes::Exploit.to_string(),
    }
  }
}

impl ExploitDB {
  fn from_html(html: &str, item: &Item) -> Self {
    let id = item.link.rsplit_once('/').unwrap_or_default().1;
    let v = html.contains("<i class=\"mdi mdi-24px mdi-check\"");
    let mut exp = ExploitDB {
      id: id.parse().unwrap_or_default(),
      file: "".to_string(),
      description: item.description.clone(),
      date_published: item.published,
      author: "".to_string(),
      r#type: "".to_string(),
      platform: "".to_string(),
      port: None,
      date_added: Default::default(),
      date_updated: item.published,
      verified: v as u8,
      codes: None,
      tags: None,
      aliases: None,
      screenshot_url: None,
      application_url: None,
      source_url: None,
    };
    let mut cve_list = vec![];
    for line in html.lines() {
      if line.contains("<a href=\"https://nvd.nist.gov/vuln/detail/CVE-") {
        if let Some(u) = line.trim().trim_end_matches('"').strip_prefix("<a href=\"") {
          if let Some((_, id)) = u.rsplit_once('/') {
            cve_list.push(id.to_string());
          };
        };
      } else if line.contains("<a href=\"/?platform=") {
        if let Some(platform) = line
          .trim()
          .trim_end_matches("\">")
          .strip_prefix("<a href=\"/?platform=")
        {
          exp.platform = platform.to_string();
        };
      } else if line.contains("<a href=\"/?type=") {
        if let Some(t) = line
          .trim()
          .trim_end_matches("\">")
          .strip_prefix("<a href=\"/?type=")
        {
          exp.r#type = t.to_string();
        };
      } else if line.contains("<pre><code class=\"language-") {
        if let Some(u) = line
          .trim()
          .trim_end_matches('"')
          .strip_prefix("<pre><code class=\"language-")
        {
          if let Some((l, _)) = u.split_once('"') {
            exp.file = format!(
              "exploits/{}/{}/{}.{}",
              exp.platform,
              exp.r#type,
              id,
              l.to_lowercase()
            );
          };
        };
      }
    }
    exp.codes = Some(cve_list.join(";"));
    exp
  }
  pub fn update(&self, conn: &mut Connection) {
    let new_exp: CreateKnowledgeBase = self.clone().into();
    if let Some(code_list) = new_exp.meta.get_hashset("tags") {
      for c in code_list {
        if c.starts_with("CVE-") {
          // 是CVE
          if let Err(err) = create_or_update_exploit(conn, &new_exp, Some(c.clone())) {
            println!("是CVE： import knowledge_base err: {:?}", err);
          }
        } else {
          // code不为空，但是不是cve
          if let Err(err) = create_or_update_exploit(conn, &new_exp, None) {
            println!(
              "code不为空，但是不是cve： import knowledge_base err: {:?}",
              err
            );
          }
        }
      }
    } else {
      // code为空
      if let Err(err) = create_or_update_exploit(conn, &new_exp, None) {
        println!("code为空：import knowledge_base err: {:?}", err);
      }
    }
  }
}

async fn get_info_from_exploit_url(conn: &mut Connection, item: &Item) {
  let mut headers = header::HeaderMap::new();
  let ua = "Mozilla/5.0 (X11; Linux x86_64; rv:94.0) Gecko/20100101 Firefox/94.0";
  headers.insert(header::USER_AGENT, header::HeaderValue::from_static(ua));
  if let Ok(resp) = reqwest::ClientBuilder::new()
    .default_headers(headers)
    .build()
    .unwrap_or_default()
    .get(&item.link)
    .send()
    .await
  {
    let html = resp.text().await.unwrap_or_default();
    let kb_item = ExploitDB::from_html(&html, item);
    let new_exp: CreateKnowledgeBase = kb_item.clone().into();
    if !new_exp.path.is_empty()
      && kb_item.id != 0
      && !kb_item.r#type.is_empty()
      && !kb_item.platform.is_empty()
    {
      if let Err(err) = create_or_update_exploit(conn, &new_exp, kb_item.codes) {
        println!("import nuclei knowledge_base err: {:?}", err);
      }
    }
  }
}
